## Обработка исключений (#1)

Создайте `Hamster` как `data class` с параметром конструктора `val name: String`.

Теперь создайте класс `HamsterCageException`, который наследует `Exception`.
`HamsterCageException` принимает параметр конструктора `val msg: String` и переопределяет `toString()`, чтобы он создавал строку `"HamsterCageException: $msg"`. Создайте три исключения, наследующиеся от `HamsterCageException`:

- `CageFullException(val limit: Int)`: вызывает конструктор базового класса с
  `"Cage full > $limit"`.

- `NoSuchHamsterException(val id: String)`: вызывает конструктор базового класса
  с `"No Hamster $id"`.

- `OutOfWaterException`: вызывает конструктор базового класса с `"Cage out of water"`.

Создайте класс `HamsterCage(val capacity: Int)`. Вы не можете положить другого `Hamster` в `HamsterCage`, если оно достигло `capacity`.

В `HamsterCage` храните `Hamsters` в `HashSet`. Напишите следующие функции-члены:

- `add(h: Hamster)` выбрасывает `CageFullException(capacity)`, если клетка достигла `capacity`.

- `get(name: String)` выбрасывает `NoSuchHamsterException(name)`, если `Hamster` с таким `name` не найден.

- `feed()` генерирует случайное число от 0 до 10 и выбрасывает
  `OutOfWaterException()`, если результат больше 8. Если успешно, возвращает
  `"Feeding complete"`.

Начальный код содержит инициализированный `List` из `Hamsters`. Напишите функцию `test(hc: HamsterCage)`, которая использует каждую функцию-член:

- `add()` посредством попытки добавить каждый объект в `hamsters`.

- `get()` с использованием для `name` первого `Hamster` в `hamsters`, затем используйте `"Morty"`.

- Вызовите `feed()` три раза.

`test()` вызывает `trace()` для любой операции, которая производит результат. В каждом случае ловите потенциальное исключение и вызывайте `trace()` на этом исключении.

`main()` содержит начальный код, передающий `HamsterCage` в `test()`, и ожидаемый вывод для `trace`.

Рассмотрите сложность получившегося кода и оцените, какие исключения можно было бы заменить на обычный не исключительный код.

<sub> Эта задача не содержит автоматических тестов,
поэтому она всегда отмечается как "Правильная" при запуске "Проверка".
Пожалуйста, сравните свое решение с предоставленным! </sub>