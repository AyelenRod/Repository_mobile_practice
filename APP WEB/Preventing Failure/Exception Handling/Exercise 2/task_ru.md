## Обработка исключений (#2)

Исходный код определяет иерархию исключений и три функции:

- `findNumber(s: String)` ищет `s` и возвращает `String`, содержащий
  число. Выбрасывает `NoNumber`, если число не найдено.

- `convertNumber(s: String)` преобразует `s` в `Int`. Выбрасывает `BadNumber`,
  если `s` не может быть преобразовано в `Int`.

- `embedNumber(n: Int)` создает `String`, содержащую `n` в некоторых буквах.

Ваша задача определить две функции:

- `justFail(s: String)` вызывает три вышеуказанные функции, вкладывая вызовы
  один в другой. Она находит число внутри `String`, преобразует его в `Int`,
  встраивает этот `Int` в `String` и вызывает `trace()` с результатом.

- `recover(s: String)` вызывает каждую из вышеперечисленных функций поочередно,
  восстанавливаясь после любых сбоев для каждого вызова, чтобы следующий вызов
  мог быть успешным. Если `findNumber()` терпит неудачу, восстановление
  выдает `String` `"0"`. Если `convertNumber()` терпит неудачу, восстановление
  выдает `-1`. В конце `recover()` вызовите `trace()` с результатом.

Оставшийся исходный код тестирует две вышеупомянутые функции.

Обратите внимание на возможные эффекты, вызванные исключениями:

1. Если функция может вызвать одно или несколько исключений, вызовы этой
   функции могут быть значительно более сложными.

2. Концепция восстановления предполагает, что есть *способ*, позволяющий
   восстановиться после неудачного вызова функции. Однако часто это попросту
   не так.

<sub> Эта задача не содержит автоматического тестирования,
поэтому она всегда отмечена как "Правильно", когда вы запускаете "Проверить".
Пожалуйста, сравните свое решение с предоставленным! </sub>