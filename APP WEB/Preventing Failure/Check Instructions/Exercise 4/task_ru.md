## Проверка инструкций (#4)

Создайте `class Tank(val capacity: Double)`, где `capacity` — это максимальное количество, которое может вместить `Tank`. Добавьте свойство `safetyGap`, которое вычисляет 2% зазор пустого пространства, которое должно быть сохранено в верхней части `Tank`. Текущее количество в `Tank` хранится в свойстве только для чтения, называемом `level`. Фактически допустимое количество, которое может содержать бак, называется `maxLevel`.

Определите две функции-члены для `Tank`:

- `add(quantity: Double): Double`, где `quantity` должно быть положительным. Добавьте ровно столько `quantity`, чтобы заполнить бак до `maxLevel`, а остальное поместите в `remainder`. В конце функции проверьте, что `level` больше нуля, что `level` меньше или равно `maxLevel`, а `remainder` больше или равно нулю. Затем верните `remainder`.

- `drain(quantity: Double)`, где `quantity` должно быть положительным и не может превышать `level` в `Tank`. После удаления `quantity` из бака проверьте, что `level` больше или равно нулю.

Стартовый код в `main()` тестирует ваш класс `Tank` и показывает, какие сообщения об ошибках использовать в ваших вызовах `require()` и `check()`.

Обратите внимание, что вызовы `check()` не приведут к ошибке, если внутренняя логика функции корректна. То есть, если `check()` выбрасывает исключение, это указывает на ошибку программирования. По этой причине вызовы `check()` могут быть удалены после проверки кода, чтобы улучшить производительность. Лучше оставить их для поддержания верификации кода, но если это невозможно, вы можете преобразовать тесты `check()` в модульные тесты (см. [Unit Testing]).

<sub> Эта задача не содержит автоматических тестов, поэтому она всегда помечается как "Правильная", когда вы запускаете "Проверку". Пожалуйста, сравните ваше решение с предоставленным! </sub>