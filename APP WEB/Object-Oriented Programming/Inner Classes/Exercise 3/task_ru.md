## Вложенные классы (#3)

Определите `class Container<T>(iterable: Iterable<T>)` с свойством `items`, которое является `MutableList<T>`. Инициализируйте `items`, используя `iterable` в качестве источника данных. Включите функцию `add(x: T)`, которая добавляет элемент в `items`. Определите функцию-член `selector()`, которая возвращает объект анонимного внутреннего класса, реализующего:

```kotlin
interface Selector<T> {
  fun end(): Boolean
  fun current(): T
  fun next()
}
```

- `end()` сообщает, находится ли указатель в конце списка `items`

- `current()` возвращает текущий элемент, на который указывает `Selector`

- `next()` переходит к следующему элементу в списке.

Определите автономную функцию `<T> traceAll(select: Selector<T>)`, которая использует `select` для добавления всех значений `current()` в `trace`, а затем возвращает `trace`.

Теперь сделайте так, чтобы `Container` наследовался от `Iterable<T>`, и добавьте функцию `iterator()`, которая возвращает экземпляр анонимного внутреннего класса, наследующегося от `Iterator<T>`. Добавьте автономную функцию `<T> traceAll2(ib: Iterable<T>)`, которая ведет себя так же, как `traceAll()`.

Исходный код содержит `main()` с тестами для проверки вашего кода.

<sub> Эта задача не содержит автоматических тестов, поэтому она всегда отмечается как "Correct" при запуске "Check". Пожалуйста, сравните ваше решение с предоставленным! </sub>